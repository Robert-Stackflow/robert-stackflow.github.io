<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>便签墙</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-image: linear-gradient(0deg, #eee 1px, transparent 0),
          linear-gradient(90deg, #eee 1px, transparent 0);
        background-size: 30px 30px;
        color: #333;
        min-height: 100dvh;
        overflow: hidden;
      }

      body.is-mobile {
        overflow-y: auto;
      }

      #board {
        position: relative;
        width: 100vw;
        height: 100dvh;
        overflow: hidden;
      }

      body.is-mobile #board {
        height: auto;
        min-height: 100dvh;
      }

      .card {
        position: absolute;
        width: 220px;
        border-radius: 12px;
        box-shadow: 0 16px 35px rgba(0, 0, 0, 0.2);
        background: #fff;
        border: 1px solid rgba(0, 0, 0, 0.08);
        overflow: hidden;
        opacity: 0;
        transform-origin: center;
        transition: transform 0.35s ease, opacity 0.35s ease, left 0.35s ease,
          top 0.35s ease, width 0.35s ease, height 0.35s ease,
          border-radius 0.35s ease;
        animation: float 4s ease-in-out infinite alternate;
      }

      @keyframes float {
        from {
          transform: translateY(0) rotate(var(--angle, 0deg)) scale(1);
        }
        to {
          transform: translateY(-6px) rotate(calc(var(--angle, 0deg) + 1deg))
            scale(1.02);
        }
      }

      .card.dragging {
        transition: none;
        box-shadow: 0 22px 45px rgba(0, 0, 0, 0.35);
      }

      .card.maximized {
        box-shadow: 0 28px 60px rgba(0, 0, 0, 0.4);
        animation: none;
        border: none;
      }

      .card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.7);
        cursor: grab;
        user-select: none;
        touch-action: pan-y;
      }

      .card-header.dragging {
        cursor: grabbing;
      }

      .window-controls {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .window-controls .control {
        position: relative;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 1px solid rgba(0, 0, 0, 0.08);
        background: #ccc;
        cursor: pointer;
        outline: none;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .window-controls .control.close {
        background: #ff5f57;
        border-color: #e0443e;
      }

      .window-controls .control.minimize {
        background: #febb2e;
        border-color: #dea123;
      }

      .window-controls .control.maximize {
        background: #28c840;
        border-color: #1aab2c;
      }

      .window-controls .control::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .card-header:hover .window-controls .control::after {
        opacity: 0.8;
      }

      .window-controls .control.close::after {
        content: "×";
        width: auto;
        height: auto;
        background: none;
        font-size: 10px;
        line-height: 1;
        font-weight: 700;
        color: rgba(0, 0, 0, 0.7);
      }

      .window-controls .control.minimize::after {
        width: 6px;
        height: 2px;
        background: rgba(0, 0, 0, 0.6);
      }

      .window-controls .control.maximize::after {
        width: 6px;
        height: 6px;
        background: linear-gradient(
          45deg,
          rgba(0, 0, 0, 0.6) 0%,
          rgba(0, 0, 0, 0.6) 45%,
          transparent 45%,
          transparent 55%,
          rgba(0, 0, 0, 0.6) 55%,
          rgba(0, 0, 0, 0.6) 100%
        );
      }

      .card-title {
        font-size: 13px;
        font-weight: 600;
        color: rgba(0, 0, 0, 0.55);
        padding-left: 10px;
        flex: 1;
      }

      .card-body {
        padding: 16px;
        font-size: 16px;
        line-height: 1.4;
        font-weight: 600;
        color: rgba(0, 0, 0, 0.72);
      }

      @media (max-width: 768px) {
        .card {
          width: 180px;
          border-radius: 10px;
        }

        .card-body {
          padding: 14px;
          font-size: 14px;
        }

        .card-title {
          font-size: 12px;
        }
      }

      /* === 输入框弹窗 === */
      #inputModal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      #inputModal.active {
        visibility: visible;
        opacity: 1;
      }

      #inputBox {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        width: 300px;
        text-align: center;
      }

      #inputBox textarea {
        width: 100%;
        height: 80px;
        border-radius: 8px;
        border: 1px solid #ccc;
        padding: 8px;
        font-size: 14px;
        resize: none;
        outline: none;
        margin-top: 12px;
      }

      #inputBox button {
        margin-top: 12px;
        background: #28c840;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      #inputBox button:hover {
        background: #1ea233;
      }
    </style>
  </head>
  <body>
    <div id="board"></div>

    <div id="inputModal">
      <div id="inputBox">
        <h3>新便签</h3>
        <textarea id="noteInput" maxlength="80"></textarea>
        <br />
        <button id="addNoteBtn">投递~</button>
      </div>
    </div>

    <script>
      const board = document.getElementById("board");
      const modal = document.getElementById("inputModal");
      const addBtn = document.getElementById("addNoteBtn");
      const input = document.getElementById("noteInput");

      const messages = [
        "保持好心情",
        "多喝水哦",
        "今天辛苦啦",
        "早点休息",
        "记得吃水果",
        "加油，你可以的",
        "祝你顺利",
        "保持微笑呀",
        "愿所有烦恼都消失",
        "期待下一次见面",
        "梦想总会实现",
        "天气冷了，多穿衣服",
        "记得给自己放松",
        "每天都要元气满满",
        "今天也要好好爱自己",
        "适当休息一下",
      ];

      const titles = [
        "温馨提示",
        "小小便签",
        "贴心话语",
        "每日一句",
        "暖心提醒",
        "快乐便签",
      ];

      const colors = [
        "#ffe0e3",
        "#c7f0ff",
        "#ffd8a8",
        "#d9f2d9",
        "#e5d7ff",
        "#f9f7d9",
        "#d2f0f8",
        "#ffd4f5",
      ];

      const cardStates = new WeakMap();
      // Reserve a very high层级给全屏卡片，避免被后续元素覆盖
      const MAXIMIZED_LAYER = 1000000;
      let activeMaximizedCard = null;
      let isMobile =
        window.matchMedia("(pointer: coarse)").matches ||
        window.innerWidth <= 768;
      const maxCards = isMobile ? 120 : 180; // 限制 DOM 节点数量，减轻移动端压力
      const initialCardCount = isMobile ? 1 : 1;
      const spawnInterval = isMobile ? 700 : 400;
      let zIndexCursor = 200;

      document.body.classList.toggle("is-mobile", isMobile);

      function randomFrom(array) {
        return array[Math.floor(Math.random() * array.length)];
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function applyTransform(card, state) {
        const scale = state.scale ?? 1;
        const translateX = state.translateX ?? 0;
        const translateY = state.translateY ?? 0;
        const angle = state.angle ?? 0;
        card.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale}) rotate(${angle}deg)`;
      }

      function bringToFront(card) {
        if (card === activeMaximizedCard) {
          card.style.zIndex = MAXIMIZED_LAYER;
          return;
        }

        zIndexCursor += 1;
        if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER) {
          zIndexCursor = MAXIMIZED_LAYER - 1;
        }

        card.style.zIndex = zIndexCursor;
      }

      function setupCardInteractions(card) {
        const header = card.querySelector(".card-header");
        const closeBtn = card.querySelector(".control.close");
        const minimizeBtn = card.querySelector(".control.minimize");
        const maximizeBtn = card.querySelector(".control.maximize");

        closeBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          closeCard(card);
        });

        minimizeBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          minimizeCard(card);
        });

        maximizeBtn.addEventListener("click", (event) => {
          event.stopPropagation();
          toggleMaximize(card);
        });

        header.addEventListener("pointerdown", (event) => {
          if (event.pointerType === "touch") return;
          startDrag(event, card);
        });

        card.addEventListener("pointerdown", () => {
          bringToFront(card);
        });

        header.addEventListener("dblclick", (event) => {
          if (!event.target.closest(".control")) {
            toggleMaximize(card);
          }
        });
      }

      function closeCard(card) {
        const state = cardStates.get(card);
        if (!state || state.closing) return;
        if (card === activeMaximizedCard) {
          activeMaximizedCard = null;
        }
        state.closing = true;
        state.scale = 0.1;
        card.style.opacity = "0";
        applyTransform(card, state);

        const handleTransitionEnd = (event) => {
          if (event.propertyName === "opacity") {
            card.removeEventListener("transitionend", handleTransitionEnd);
            card.remove();
          }
        };

        card.addEventListener("transitionend", handleTransitionEnd);
      }

      function minimizeCard(card) {
        const state = cardStates.get(card);
        if (!state || state.closing) return;

        // 最小化动画：缩小并淡出到底部，结束时移除节点释放内存
        const runMinimize = () => {
          state.closing = true;
          bringToFront(card);
          const bottom = Math.max(window.innerHeight - 24, 0);
          const targetLeft = clamp(
            state.left,
            16,
            Math.max(window.innerWidth - card.offsetWidth - 16, 16)
          );

          state.left = targetLeft;
          state.top = bottom;
          state.scale = 0.1;
          state.angle = 0;
          card.style.left = `${targetLeft}px`;
          card.style.top = `${bottom}px`;
          card.style.opacity = "0.35";

          applyTransform(card, state);

          const handleTransitionEnd = (event) => {
            if (event.propertyName === "transform") {
              card.removeEventListener("transitionend", handleTransitionEnd);
              card.remove();
            }
          };

          card.addEventListener("transitionend", handleTransitionEnd);
        };

        if (state.maximized) {
          activeMaximizedCard = null;
          state.maximized = false;
          card.classList.remove("maximized");
          card.style.borderRadius = "12px";
          state.left = 0;
          state.top = 0;
          state.scale = 1;
          state.angle = 0;
          applyTransform(card, state);

          requestAnimationFrame(() => {
            requestAnimationFrame(runMinimize);
          });
          return;
        }

        runMinimize();
      }

      function toggleMaximize(card) {
        const state = cardStates.get(card);
        if (!state || state.closing) return;

        if (state.maximized) {
          restoreFromMaximize(card, state);
        } else {
          maximizeCard(card, state);
        }
      }

      function maximizeCard(card, state) {
        state.beforeMaximize = {
          left: state.left,
          top: state.top,
          scale: state.scale ?? 1,
          width: card.offsetWidth,
          height: card.offsetHeight,
          angle: state.angle ?? 0,
        };

        card.classList.add("maximized");
        card.style.left = "0px";
        card.style.top = "0px";
        card.style.width = `${window.innerWidth}px`;
        card.style.height = `${window.innerHeight}px`;
        card.style.borderRadius = "0";

        state.left = 0;
        state.top = 0;
        state.scale = 1;
        state.angle = 0;
        applyTransform(card, state);
        activeMaximizedCard = card;
        bringToFront(card);
        state.maximized = true;
      }

      function restoreFromMaximize(card, state) {
        const previous = state.beforeMaximize;
        if (!previous) return;

        card.classList.remove("maximized");
        card.style.left = `${previous.left}px`;
        card.style.top = `${previous.top}px`;
        card.style.width = `${previous.width}px`;
        card.style.height = `${previous.height}px`;
        card.style.borderRadius = "12px";

        state.left = previous.left;
        state.top = previous.top;
        state.scale = previous.scale ?? 1;
        state.angle = previous.angle ?? state.angle ?? 0;
        applyTransform(card, state);
        state.maximized = false;
        if (activeMaximizedCard === card) {
          activeMaximizedCard = null;
        }
        bringToFront(card);
        state.lastPosition = { left: state.left, top: state.top };

        setTimeout(() => {
          if (!state.maximized) {
            card.style.width = "";
            card.style.height = "";
            state.width = card.offsetWidth;
            state.height = card.offsetHeight;
          }
        }, 360);
      }

      function startDrag(event, card) {
        const control = event.target.closest(".control");
        if (control) return;

        const state = cardStates.get(card);
        if (!state || state.closing || state.maximized) return;

        // 鼠标拖拽使用 rAF 节流，避免频繁触发布局计算
        event.preventDefault();
        bringToFront(card);

        const header = card.querySelector(".card-header");
        card.classList.add("dragging");
        header.classList.add("dragging");

        state.dragging = true;
        state.dragOffsetX = event.clientX - state.left;
        state.dragOffsetY = event.clientY - state.top;

        let dragFrame = null;
        let pendingLeft = state.left;
        let pendingTop = state.top;

        const commitDrag = () => {
          dragFrame = null;
          const maxLeft = Math.max(window.innerWidth - card.offsetWidth, 0);
          const maxTop = Math.max(window.innerHeight - card.offsetHeight, 0);
          state.left = clamp(pendingLeft, -card.offsetWidth * 0.4, maxLeft);
          state.top = clamp(pendingTop, -card.offsetHeight * 0.4, maxTop);
          card.style.left = `${state.left}px`;
          card.style.top = `${state.top}px`;
        };

        const handlePointerMove = (moveEvent) => {
          if (!state.dragging) return;

          pendingLeft = moveEvent.clientX - state.dragOffsetX;
          pendingTop = moveEvent.clientY - state.dragOffsetY;
          if (dragFrame === null) {
            dragFrame = requestAnimationFrame(commitDrag);
          }
        };

        const handlePointerUp = () => {
          state.dragging = false;
          state.lastPosition = { left: state.left, top: state.top };
          card.classList.remove("dragging");
          header.classList.remove("dragging");
          if (dragFrame !== null) {
            cancelAnimationFrame(dragFrame);
            commitDrag();
          }
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp);
        };

        document.addEventListener("pointermove", handlePointerMove);
        document.addEventListener("pointerup", handlePointerUp);
      }

      function createCard(text) {
        const card = document.createElement("div");
        card.className = "card";

        const color = randomFrom(colors);
        const angleRange = isMobile ? 6 : 10;
        const angle = (Math.random() - 0.5) * angleRange;
        const cardWidth = isMobile ? 180 : 220;
        const cardHeight = isMobile ? 130 : 140;
        const horizontalMargin = isMobile ? 12 : 16;
        const verticalMargin = isMobile ? 12 : 20;
        const left =
          horizontalMargin +
          Math.random() *
            Math.max(window.innerWidth - cardWidth - horizontalMargin * 2, 0);
        const top =
          verticalMargin +
          Math.random() *
            Math.max(window.innerHeight - cardHeight - verticalMargin * 2, 0);

        card.style.background = color;
        card.style.left = `${left}px`;
        card.style.top = `${top}px`;
        if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER - 2) {
          zIndexCursor = MAXIMIZED_LAYER - 2;
        }
        card.style.zIndex = ++zIndexCursor;

        card.innerHTML = `
					<div class="card-header">
						<div class="window-controls">
							<button class="control close" type="button" aria-label="关闭"></button>
							<button class="control minimize" type="button" aria-label="最小化"></button>
							<button class="control maximize" type="button" aria-label="最大化"></button>
						</div>
						<div class="card-title">${randomFrom(titles)}</div>
					</div>
					<div class="card-body">${text != undefined ? text : randomFrom(messages)}</div>
				`;

        const state = {
          angle,
          scale: isMobile ? 0.85 : 0.7,
          translateX: 0,
          translateY: 0,
          left,
          top,
          maximized: false,
          closing: false,
          lastPosition: { left, top },
        };

        cardStates.set(card, state);
        applyTransform(card, state);
        board.appendChild(card);

        state.width = card.offsetWidth;
        state.height = card.offsetHeight;

        requestAnimationFrame(() => {
          state.scale = 1;
          applyTransform(card, state);
          card.style.opacity = "1";
        });

        setupCardInteractions(card);

        if (board.children.length > maxCards) {
          const oldest = board.firstElementChild;
          if (oldest && oldest !== card) {
            oldest.remove();
          }
        }

        timeoutObj = setTimeout(
          () => closeCard(card),
          isMobile ? 30000 : 60000
        );
        card.addEventListener("pointerenter", () => {
          clearTimeout(timeoutObj);
        });
        card.addEventListener("pointerleave", () => {
          timeoutObj = setTimeout(
            () => closeCard(card),
            isMobile ? 15000 : 30000
          );
        });
      }

      board.addEventListener("click", (e) => {
        if (e.target === board) {
          input.placeholder = randomFrom(messages);
          modal.classList.add("active");
          input.value = "";
          input.focus();
        }
      });

      addBtn.addEventListener("click", () => {
        const text = input.value.trim();
        modal.classList.remove("active");
        if (text === "") return;
        createCard(text);
      });

      modal.addEventListener("click", (e) => {
        if (e.target === modal) modal.classList.remove("active");
      });

      for (let i = 0; i < initialCardCount; i++) {
        setTimeout(createCard, i * (isMobile ? 60 : 40));
      }

      setInterval(() => {
        createCard();
      }, spawnInterval);

      window.addEventListener("resize", () => {
        isMobile =
          window.matchMedia("(pointer: coarse)").matches ||
          window.innerWidth <= 768;
        // 视口变化时重新切换移动端模式，并同步全屏卡片的宽高
        document.body.classList.toggle("is-mobile", isMobile);

        document.querySelectorAll(".card.maximized").forEach((card) => {
          card.style.width = `${window.innerWidth}px`;
          card.style.height = `${window.innerHeight}px`;
        });
      });
    </script>
  </body>
</html>
